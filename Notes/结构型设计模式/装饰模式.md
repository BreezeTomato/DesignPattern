
### 装饰模式的定义

通常情况下，扩展类的功能可以通过[[继承]]实现，但是扩展越多，子类越多。装饰模式是一种**结构型设计模式**，可以**在不定义子类的情况下动态的给对象添加一些额外的功能**。具体的做法是将原始对象放入包含行为的特殊[[封装]]类（装饰类），从而**为原始对象动态添加新的行为，而无需修改其代码**。

假设有一个基础的图形类，若想为其添加颜色、边框、阴影等功能，如果每个功能都实现一个子类，就会导致产生大量的类，这时候就可以考虑使用装饰模式来动态地添加，而不需要修改图形本身的代码，这样可以使得代码更加灵活、更容易维护和扩展。

### 装饰模式的基本结构

装饰模式包含以下四个主要角色：
- 组件`Component`：通常是[[抽象类]]或者接口，是具体组件和装饰者的父类，定义了具体组件需要实现的方法.
- 具体组件`ConcreteComponent`：实现了Component的接口具体类，是被装饰的对象。
- 装饰类`Decorator`：一个[[抽象类]]，给具体组件添加功能，但是具体的功能由其子类具体装饰者完成，持有一个指向Component对象的引用。
- 具体装饰类`ConcreteDecorator`：扩展Decorator类，负责向Component对象添加新的行为。

![[Pasted image 20250301162740.png]]

### 装饰模式的基本实现

装饰模式的实现包括了以下步骤：
1. 定义Component接口；
2. 实现ConcreteComponent；
3. 定义Decorator装饰类，[[继承]]自Component；
4. 定义具体的装饰者实现，给具体组件对象添加功能。
5. 在客户端使用。

### 装饰模式的应用场景

装饰模式通常在以下几种情况使用：

- 当需要给一个现有类添加附加功能，但由于某些原因不能使用[[继承]]来生成子类进行扩充时，可以使用装饰模式。
- 动态的添加和[[override|覆盖]]功能：当对象的功能要求可以动态地添加，也可以再动态地撤销时可以使用装饰模式。
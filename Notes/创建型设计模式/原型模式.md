
### 原型模式的定义

原型模式是一种**创建型设计模式**，该模式的核心思想是**基于现有的对象创建新的对象**，而不是从头开始创建。

在原型模式中，通常有一个**原型对象**，它被用作创建新对象的模版。新对象通过复制原型对象的属性和状态来创建，而无需知道具体的创建细节。

### 原型模式的优点

如果一个对象的创建过程比较复杂时（比如需要经过一系列的计算和资源消耗），那么每次创建该对象都需要消耗资源，而通过原型模式就可以复制一个现有的对象来迅速创建/克隆一个新对象，不必关心具体的创建细节，可以降低对象创建的成本。

### 原型模式的基本结构

实现原型模式需要给原型对象声明一个克隆方法，执行该方法会创建一个当前类的新对象，并将原始对象中的成员变量复制到新生成的对象中，而不必实例化。并且在这个过程中只需要调用原型对象的克隆方法，而无需知道原型对象的具体类型。

原型模式包含两个重点模块：
- 抽象原型接口`prototype`：声明一个克隆自身的方法`clone`；
- 具体原型类`ConcretePrototype`：实现`clone`方法，复制当前对象并且返回一个新对象。

在客户端代码中，可以声明一个具体的原型类的对象，然后调用`clone()`方法复制原对象生成一个新的对象。
![[Pasted image 20250301111933.png]]

### 原型模式的基本实现

原型模式的实现过程即上述模块的实现过程：
- 创建一个[[抽象类]]或接口，声明一个克隆方法`clone`
- 实现具体原型类，重写克隆方法
- 客户端中实例化具体原型类的对象，并且调用其克隆方法来创建新的对象。

### 原型模式的使用场景

相比于直接实例化对象，通过原型模式复制对象可以减少资源消耗，提高性能，尤其在对象创建过程复杂或对象的创建代价较大的情况下。当需要频繁创建相似对象、并且可以通过克隆避免重复初始化工作的场景可以考虑使用原型模式，在克隆对象的时候还可以动态地添加或删除原型对象的属性，创造出相似但不完全相同的对象，提高了灵活性。

但是使用原型模式也需要考虑到如果**对象的内部状态包含了引用类型的成员变量**，那么实现深拷贝就会变得较为复杂，需要考虑引用类型对象的克隆问题。
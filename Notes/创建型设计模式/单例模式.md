
### 单例模式的定义

单例模式是一种**创建型设计模式**，它的核心思想是**保证一个类只有一个实例**，并提供一个全局访问点来访问这个实例。

- 只有一个实例：在整个应用程序中，只存在该类的一个实例对象，而不是创建多个相同类型的对象。
- 全局访问点：为了让其他类能够获取到这个唯一实例，该类提供了一个全局访问点（通常是一个静态方法），通过这个方法就能获得实例。

### 单例设计模式的优点

- 全局控制：保证只有一个实例，这样就可以**严格控制**客户怎样访问以及何时访问它，简单来说就是**对唯一实例的受控访问**。
- 节省资源：正是因为只有一个实例存在，就避免了多次创建相同的对象，从而能够**节省系统资源**，而且多个模块还可以通过单例实例共享数据。
- 懒加载：单例模式可以实现懒加载，只有**在需要时才能进行实例化**，这无疑能够提高程序的性能。

### 单例模式的基本要求

单例设计模式必须遵守以下规则：
1. 私有的[[构造函数]]：防止外部代码直接创建类的实例；
2. 私有的静态实例变量：保存该类的唯一实例；
3. 公有的静态方法：通过公有的静态方法来获取类的实例。

![[Pasted image 20250226162118.png]]

### 单例模式的实现

单例模式的实现方式有多种，包括懒汉式、饿汉式等。

**饿汉式**指的是在**类加载时就已经完成了实例的创建**，不管后面创建的实例有没有使用，先创建再说，所以叫做“饿汉式”。

而**懒汉式**指的是只有**在请求实例时才会创建**，如果在首次请求时还没有创建，就创建一个新的实例，如果已经创建，就返回已有的实例，意思就是需要使用时再创建，所以称为“懒汉式”。

<mark style="background: #D2B3FFA6;">需要注意：</mark>
在多线程环境下，由于饿汉式在程序启动阶段就完成了实例的初始化，因此不存在多个线程同时尝试初始化实例的问题，但是懒汉式中多个线程同时访问getInstance()方法时，并且在同一个时刻检测到实例没有被创建，就可能会同时创建实例，从而导致多个实例被创建，这种情况下我们可以采用一些同步机制，例如使用互斥锁来确保在任何时刻只有一个线程能够执行实例的创建。

- 举例说明：小明和小红都发现家里没有米了，在二者没有互相通知的情况下，都会去超市购买大米，这样就重复购买了，违背了单例模式的初衷。

下⾯以Java的代码作为实例，说明单例模式的基本写法：

1. 饿汉式：实例在类加载时就被创建，这种方式的实现相对比较简单，但是实例有可能因为没有被使用而造成资源浪费。
```
public class Singleton {

	private static final Singleton instance = new Singleton();
	
	private Singleton() {
	// 私有构造⽅法，防⽌外部实例化
	}
	
	public static Singleton getInstance() {
		return instance;
	}
	
} 
```

2. 懒汉式：第一次使用时才进行创建。
```
public class Singleton {
	private static Singleton instance;
	
	private Singleton() {
	// 私有构造⽅法，防⽌外部实例化
	}
	// 使⽤了同步关键字来确保线程安全, 可能会影响性能
	
	public static synchronized Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
	
}
```

### 单例模式的使用场景

1. 资源共享
	多个模块共享某个资源的时候，可以使用单例模式，比如应用程序需要一个全局配置器来存储和管理配置信息、亦或是使用单例模式管理数据库连接池。

2. 只有一个实例
	当系统中某个类只需要一个实例来协调行为的时候，可以考虑使用单例模式，比如管理应用程序中的缓存，确保只有一个缓存实例，避免重复的缓存创建和管理，或者使用单例模式来创建和管理线程池。

3. 懒加载
	如果对象创建本身比较消耗资源，而且可能在整个程序中都不一定会使用，可以考虑使用单例模式实现懒加载。